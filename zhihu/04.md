#! https://zhuanlan.zhihu.com/p/413074200
# 从零开始手敲自举编译器（四）：栈

[目录/序言](https://zhuanlan.zhihu.com/p/412017892)

本文对应whoiscc/miniboot仓库的[b588da]提交，使用示例：

```bash
$ python3 misc.py prog.cfg 
** SUMMARY
* Total page number       : 2
* Protected page number   : 2
* Instruction number      : 54
* Data size (bytes)       : 0
* Next allocate address   : 0x1000000
** PROGRAM START
** PROGRAM END
* Total page number       : 2050
* Next allocate address   : 0x1800000
* Exit code               : 7
```

[b588da]: https://github.com/whoiscc/miniboot/tree/b588daefa3adc33d0d10ba05f1a29c753fc44e07

可以看到上一篇文首示例中的hello world消失了，实际上我们的commit也倒退了呢：）倒叙怎么说，倒叙（

----

在前面的文章中展示了基于MISC的hello world程序。想必各位也发现了，这个程序最大的问题是它根本没有栈，自然也没有局部变量——字符串地址是从数据页读来的，字符串长度是用立即数直接硬编码的，突出的就是一个简单粗暴。

尽管对于生活在现代文明中的我们来说有些意外，但栈还真就不是程序运行时的一个必要组成部分。这里且不说像Haskell之类的，因为彻底远离了底层架构而将栈替换为了其他抽象的高级语言；就比如说FORTRAN 77，编译器将所有的变量都按照全局/静态变量的方式处理，在数据段的固定地址分配内存，也不是不行。

> 说起来，MISC汇编和上古时期带编号的FORTRAN或者BASIC还真有那么一点像。

少了栈究竟少掉了什么？依然可以有函数，依然可以结构化编程，只不过就是不能递归了而已，因为递归需要一个函数的局部变量的多个实例同时存在。

乍一看好像递归也不是什么要紧的特性，只可惜，我们现在要写的不是别的，恰恰就是编译器。我们恰恰就需要写语法分析器，我们恰恰就没有yacc可以白嫖，只能手写递归下降语法分析。我们恰恰就需要递归。

> 1号伏笔回收，接着读下去吧，嘻嘻。

----

想要有栈，就要解决两个问题：栈的内存从哪来，以及程序怎么访问栈。

对于一个普通的Linux用户态程序，它的栈是操作系统将其加载进内存时为其分配好的；对于一个普通的Linux内核态程序（模块），它和Linux内核共享一个栈，这个栈是整个操作系统启动时引导程序分配的。对于MISC来说，这两种负责初始化栈的角色都不存在，我们有的只有一个中断。

一个MISC程序，必须在从入口开始执行以后，手动执行一次中断，自己动手给自己申请一片内存出来，然后把它当成栈来用。当然，后面等我们需要有堆的时候也得是这么干。

Linux中申请内存的系统调用不止一种，比如glibc的堆实现就会视情况调用`sbrk`或者`mmap`。MISC中尽可能用一种中断操作解决所有内存申请，后面如果发现不够泛用可能会进行微调。

`int 0x2`。处理该中断时，机器从A读取申请的内存页数，分配连续的对应大小的内存，将首地址写入B中。这里没有遵循「优先写A」原则，一个是因为这是一个少有的，返回结果为地址的操作；另外对于想要得到分配内存终地址的场合（虽然暂时没想到这种场合），跟一句`add`可以方便地实现目标。

有了中断，我们的程序入口逻辑就可以相应地编写了

```
0x400000
; allocate (2048)10 pages (8MB) as stack
shl     40
imm     800
int     2
; assign stack base address to %D
; %D <- $B
ldb
std
```

文首示例中，程序开始执行时只分配了2个指令页，而结束执行时一共分配了2050个页，多出来的页就是从这里来的捏。

> Linux的默认堆栈大小是10MB，这里选择的值与之相近。由于编程规范（后面会讲）的缘故，MISC程序会大量地消耗和浪费栈空间，所以后面视情况可能会加大栈。

正如前面的文章中所提到的，D很适合用于维护栈的基地址，这里我们确实把拿到的栈地址存入了D。所以接下来我们可以着手解决第二个问题了。

----

如各位所了解的，x86架构访问栈的习惯是：
* 栈向低地址方向生长。
* 基于`sp`寄存器中存储的，当前栈顶地址访问局部变量。栈顶地址小于所有栈内地址，所以偏移量是正数，越晚分配的变量偏移量越小。
* 由于`push`和`pop`的存在，每个栈变量相对`sp`的偏移量根据上下文时常变化。

不管是GodV反向大招一样的定义还是上下文有关的使用方式，这套方法都太不适合人类进行脑内模拟跟踪了。因此MISC在这里提出一套几乎正好相反的标准：
* 栈向高地址方向生长。
* D存放栈底地址。偏移量为正数，越晚分配的变量偏移量越大。
* 无函数调用时，栈底地址固定不变，使用相同的偏移量总会找到同一个栈变量。

作为一个例子，可以来看`prog/400_start.misc`结尾

```
; src = $D + 256
ldd
stb
shl     40
imm     100
add
stb
ld
```

> 关于整篇代码，会在后面讲调用栈的时候再介绍。

这里我们想要将栈内偏移量为256字节处的变量加载进寄存器。所以我们依次执行：
* 把栈底地址（D）放入（B）
* 把偏移量立即数放入A
* 两者相加并放入B
* 使用`ld`将变量加载进A

是有一点麻烦了。不过我们有的是办法。以上就是在MISC中初步使用栈的相关内容，我们下篇文章见。