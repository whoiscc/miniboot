#! https://zhuanlan.zhihu.com/p/412201989
# 从零开始手敲自举编译器（一）：MISC概览

[目录/序言](https://zhuanlan.zhihu.com/p/412017892)

本文对应whoiscc/miniboot仓库的[02611f]提交，使用示例：

```bash
$ python3 misc.py hi.misc 
Hello, world!
```

[02611f]: https://github.com/whoiscc/miniboot/tree/02611f6cd3b91985c2a20846840567307452c507

----

这篇文章的主角是MISC，即Minimal Instruction Set Computer，名字模仿自RISC/CISC，设定上也融入了不少现实中的梗。

> 想想上一个以Mini开头的系统已经在几十年前被北欧精神小伙按在地上摩擦了，我是不是也该用自己的名字，称其为Cowsay Instruction Set Computer呢？但是CISC已经存在了（还臭名昭著），苦恼（

本文介绍MISC架构的一些综合信息，接下来的文章中会具体介绍指令集设计和模拟器实现。

MISC的设计理念包括：
* 尽可能简化，将模拟器的实现复杂度降至最低。本文对应的提交版本中，可以支持hello world程序运行的模拟器实现不到200行代码，其中还包括了解析源码文本的部分。
* 与现实中存在的架构保持密切的关系。具体来说，始终确保指令集基本可以逐条对译为真实的机器指令，从而：
    * 在面对「你这不是真正的原生架构，所以你的编译器是假编译器」之类的指控时可以理直气壮地反击（
    * 虽然暂时没有计划，但在未来如果有必要的话，可以将MISC程序翻译成机器程序执行，来满足如性能之类的需求。
* 包含足够的功能性，满足实现一个MBL编译器的全部需求。

----

MISC采用定长指令集，每条指令的长度都是32比特。同时这是一个零操作数指令集，所有指令都对固定的寄存器进行操作，只接受零或一个立即数作为参数。目前指令集并没有定义二进制表示，所以32比特的长度是一个纯的虚拟设定，主要目的是为了让程序中的每一条指令有一个固定的内存地址。

MISC的寻址空间是64位，寄存器的长度也是64比特。这和上面一条放在一起就会出现一个尴尬的现象：将寄存器赋值为立即数无法用单条指令实现，因为32比特的指令没有空间容纳64比特的立即数。作为一个合理的妥协设定，立即数赋值指令`imm`接受24比特的立即数，设置64比特寄存器的值需要三条`imm`夹杂两条左移位操作。

> 由于指令没有操作数，所以32比特长的指令除了指令代码和立即数以外就没有别的内容了（有的指令连立即数都没有），说实话很浪费空间。同时立即数其实还可以更长一些，如28比特，都属于合理范围。毕竟是虚构的架构，细节上面就可以随意一点不用特别抠门：）

虽然寻址空间是64位，但考虑到现实中x64架构实际上地址只有48位，所以MISC也按照地址值只使用低48比特，高位恒0的设定进行相关的设计。一个直接的好处就是，将寄存器的值赋为立即数地址时，只需要两条`imm`就可以完成了。48位地址的高24位称为段（segment）地址，段地址相同的内存，即只有低24位不同的地址位于同一个段内。目前架构本身没有围绕段这个概念进行任何设计，但它会在（假想的）机器指令转译方法和代码规范中出现。

每一个段的内存区域包含2^24字节，即16MB，对于中小型命令行程序的主体来说已经足够放置代码段和数据段了（即不含堆栈），因此我们接下来一段时间的程序编写都会在第一个段中进行，即`0x0 - 0xffffff`。这个段内的地址`0x400000`被设定为可执行程序的入口，与现实中的64位ELF保持一致。

在每一个段内，按照高12位地址（即低13-24位地址），划分为页。总体上来说，一个完整的64位地址，由高到低依次是：16位0，24位段地址（多数时候也是0），12位页地址，以及12位页内偏移。一个页的大小是4096字节，即4KB，与现实中的x86架构一致（就不做大页了）；一个段中包含4096个页。

页分为数据页和指令页，指令页在程序运行期间只能由处理器进行读取，无法通过任何指令访问；数据页没有访问限制。一个页要么作为数据页包含4096字节的任意数据，要么作为指令页包含1024条指令，不能同时含有数据和指令。MISC架构似乎处于冯诺依曼架构定义的灰色地带。

MISC程序采用固定地址加载。每一条指令或数据（即全局变量）的内存地址都在程序源码中硬编码，在程序执行前由机器加载到内存中的对应位置。在程序执行过程中，访问的任何内存页，要么是在程序源码中就定义了的数据页，要么是在执行过程中通过系统调用动态获取的数据页。访问一个不属于这两者的内存页会导致段错误。

> 段错误为什么不叫页错误，页错误（page fault）为什么是指缺页错误，可恶的历史遗留包袱……

最后关于寄存器。因为是零操作数指令集，所以寄存器的数目很无所谓。MISC架构含有4个寄存器，在架构层面上没有名字和序号，为了文档的方便描述起见称为A、B、C和D。如上所言，每个寄存器的长度是64比特。具体的指令会在后面的文章中介绍，大体上来说，指令偏向于使用（尤其是写入）A，用B存放内存地址，几乎不使用D，因此D非常适合存放调用栈栈帧基址。

----

这一篇的长度已经比较可观了，我决定暂且略过对设计决策的讨论。总体上来说，MISC应该比70年代的上古芯片稍弱，比三体人列计算机稍强，够我写编译器用了。

我们下篇文章见。